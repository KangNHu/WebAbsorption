package com.liveeasy.web.absorption.core.schehule;import com.liveeasy.web.absorption.core.pipeline.DataStreamPipeline;import com.liveeasy.web.absorption.core.plugin.DownloaderPlugin;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import us.codecraft.webmagic.Task;import java.util.UUID;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.ThreadFactory;import java.util.concurrent.atomic.AtomicBoolean;import java.util.concurrent.atomic.AtomicInteger;public abstract class AbstractDataSchedule<T> implements DataStreamSchedule<T> , DataResultItemsSchedule<T>{    private static Logger logger = LoggerFactory.getLogger(AbstractDataSchedule.class);    /**     * 任务状态，运行：true 结束 ： false     * 默认当任务调度器执行任务后为运行状态z     * 给予手动关闭任务的方法     */    private AtomicBoolean status = new AtomicBoolean(false);    private ExecutorService executorService;    private int threadNum = 1;    private int interval = 0;    protected Task task;    protected DownloaderPlugin downloaderPlugin;    public void setDownloaderPlugin(DownloaderPlugin downloaderPlugin){        this.downloaderPlugin = downloaderPlugin;    }    public AbstractDataSchedule(){        executorService = Executors.newFixedThreadPool(this.threadNum , new ThreadFactory() {            private AtomicInteger index = new AtomicInteger();            @Override            public Thread newThread(Runnable r) {                return new Thread(r , "data-schedule-" + index.incrementAndGet());            }        });    }    @Override    public void setTask(Task task){        if(null != this.task){            return;        }        synchronized (this) {            if (null == this.task) {                this.task = task;            }        }    }    public void setExecutorService(ExecutorService executorService){        this.executorService = executorService;    }    @Override    public void setInterval(int millisecond) {        this.interval = millisecond;    }    @Override    public void stop() {        status.set(false);        if(!executorService.isShutdown()){            executorService.shutdown();        }    }    @Override    public void start() {        status.set(true);        executorService.execute(new Runnable() {            @Override            public void run() {                while (status.get()) {                    if(task != null) {                        try {                            if(!Thread.interrupted()){                                if(interval > 0) {                                    Thread.sleep(interval);                                }                            }                        } catch (InterruptedException e) {                        }                        execute();                    }                }            }        });    }    @Override    public boolean isClose() {        return !status.get();    }    protected abstract void execute();}