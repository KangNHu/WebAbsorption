package tech.liveeasy.spider.webmagic.schedule;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.util.UUID;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.ThreadFactory;import java.util.concurrent.atomic.AtomicBoolean;import java.util.concurrent.atomic.AtomicInteger;public abstract class AbstractDataSchedule<T> implements DataSchedule<T> {    private String key;    private Logger logger = LoggerFactory.getLogger(AbstractDataSchedule.class);    /**     * 任务状态，运行：true 结束 ： false     * 默认当任务调度器执行任务后为运行状态z     * 给予手动关闭任务的方法     */    private AtomicBoolean status = new AtomicBoolean(false);    private ExecutorService executorService;    private int threadNnm;    protected long interval = -1;    public void setInterval(int interval){        this.interval = interval;    }    public void setKey(String key){        this.key = key;    }    public AbstractDataSchedule(){        this(1);    }    public AbstractDataSchedule(int threadNnm){        this.threadNnm = threadNnm;        executorService = Executors.newFixedThreadPool(threadNnm, new ThreadFactory() {            private AtomicInteger index = new AtomicInteger();            @Override            public Thread newThread(Runnable r) {                return new Thread(r , "data-schedule-" + index.incrementAndGet());            }        });    }    public void setExecutorService(ExecutorService executorService){        this.executorService = executorService;    }    @Override    public void stop() {        status.set(false);        if(!executorService.isShutdown()){            executorService.shutdown();        }    }    @Override    public void AsyncStart() {        status.set(true);        Thread thread = new Thread(this);        thread.start();    }    @Override    public void start() {            status.set(true);            for (int i = 0 ; i < threadNnm ; i++) {                executorService.execute(new Runnable() {                    @Override                    public void run() {                        while (status.get()) {                            if (interval != -1) {                                try {                                    Thread.sleep(interval);                                } catch (InterruptedException e) {                                    logger.error("Dormant failure ；", e);                                }                            }                            try {                                execute();                            } catch (Exception e) {                                executeError(e);                            }                        }                    }                });            }            logger.info("data schedule start success");    }    protected String getKey() {        if(key != null){            return key;        }        synchronized (this){            if(key == null){                key = UUID.randomUUID().toString().replaceAll("-" , "");            }        }        return key;    }    @Override    public boolean isClose() {        return !status.get();    }    @Override    public void run() {       start();    }    protected abstract void executeError(Exception e);    protected abstract void execute() throws Exception;}